Using 1 models specified via command line
Detected 1 NVIDIA GPUs: [0]
Model gpt-oss:latest is already available.

Benchmarking gpt-oss:latest on GPU 0 (Run 1/5)
Running inference on model gpt-oss:latest on GPU 0
Ollama API response: {'response': 'Below is a **stand‚Äëalone, cross‚Äëplatform** Snake game written in pure Python (no external libraries other than the standard `curses` module).  \nIt works on Linux/macOS terminals and on Windows via the `windows-curses` package (pip install `windows-curses`).\n\n```bash\n# Linux / macOS\npython snake.py\n\n# Windows\npip install windows-curses\npython snake.py\n```\n\n---\n\n## How the code works\n\n| Section | What it does |\n|---------|--------------|\n| **Imports** | `curses`, `time`, `random` |\n| **Constants** | Game window size, speeds, key bindings |\n| **`SnakeGame` class** | Holds all state (snake body, direction, food, score). Methods handle input, movement, collision, rendering and game‚Äëover logic. |\n| **`main()`** | Sets up curses, starts the game loop, and gracefully restores terminal settings on exit. |\n\nThe snake is a list of `(y, x)` tuples (rows, columns).  \nThe food is a single coordinate.  \nMovement is handled by adding a new head and, if no food eaten, popping the tail.  \nCollisions (walls or self) trigger a game‚Äëover screen.\n\nFeel free to tweak the constants (speed, window size, etc.) to suit your taste.\n\n---\n\n## Full Code (`snake.py`)\n\n```python\n#!/usr/bin/env python3\n"""\nA simple Snake game written with the standard curses library.\n"""\n\nimport curses\nimport time\nimport random\n\n# ------------------------------------------------------------------\n# Configuration (feel free to tweak)\n# ------------------------------------------------------------------\nWINDOW_HEIGHT = 20\nWINDOW_WIDTH = 40\nSNAKE_CHAR = \'#\'\nFOOD_CHAR = \'*\'\nSPEED = 0.1            # Seconds per frame (lower = faster)\nINITIAL_SNAKE_LENGTH = 3\n\n# Direction vectors\nDIR_UP    = (-1,  0)\nDIR_DOWN  = ( 1,  0)\nDIR_LEFT  = ( 0, -1)\nDIR_RIGHT = ( 0,  1)\n\n# Mapping from arrow keys to directions\nKEY_TO_DIR = {\n    curses.KEY_UP:    DIR_UP,\n    curses.KEY_DOWN:  DIR_DOWN,\n    curses.KEY_LEFT:  DIR_LEFT,\n    curses.KEY_RIGHT: DIR_RIGHT,\n}\n\n# ------------------------------------------------------------------\n# Main game class\n# ------------------------------------------------------------------\nclass SnakeGame:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.reset()\n\n    def reset(self):\n        # Center the snake horizontally, a few rows from the top\n        start_y = WINDOW_HEIGHT // 2\n        start_x = WINDOW_WIDTH // 2\n        self.snake = [(start_y, start_x + i) for i in range(INITIAL_SNAKE_LENGTH)][::-1]  # head at front\n        self.direction = DIR_LEFT\n        self.score = 0\n        self.game_over = False\n        self.place_food()\n\n    def place_food(self):\n        """Place food at a random location not occupied by the snake."""\n        while True:\n            y = random.randint(1, WINDOW_HEIGHT - 2)\n            x = random.randint(1, WINDOW_WIDTH - 2)\n            if (y, x) not in self.snake:\n                self.food = (y, x)\n                break\n\n    def change_direction(self, new_dir):\n        """Change direction unless it\'s directly opposite to current."""\n        opp_dir = (-self.direction[0], -self.direction[1])\n        if new_dir != opp_dir:\n            self.direction = new_dir\n\n    def update(self):\n        """Move snake, handle collisions, and update score."""\n        head_y, head_x = self.snake[0]\n        delta_y, delta_x = self.direction\n        new_head = (head_y + delta_y, head_x + delta_x)\n\n        # Collision with walls\n        if (new_head[0] <= 0 or new_head[0] >= WINDOW_HEIGHT - 1 or\n            new_head[1] <= 0 or new_head[1] >= WINDOW_WIDTH - 1):\n            self.game_over = True\n            return\n\n        # Collision with self\n        if new_head in self.snake:\n            self.game_over = True\n            return\n\n        # Move snake\n        self.snake.insert(0, new_head)\n\n        # Check for food\n        if new_head == self.food:\n            self.score += 1\n            self.place_food()\n        else:\n            self.snake.pop()  # remove tail\n\n    def draw(self):\n        """Render the current state."""\n        self.stdscr.clear()\n\n        # Draw borders\n        for x in range(WINDOW_WIDTH):\n            self.stdscr.addch(0, x, \'#\')\n            self.stdscr.addch(WINDOW_HEIGHT - 1, x, \'#\')\n        for y in range(WINDOW_HEIGHT):\n            self.stdscr.addch(y, 0, \'#\')\n            self.stdscr.addch(y, WINDOW_WIDTH - 1, \'#\')\n\n        # Draw food\n        food_y, food_x = self.food\n        self.stdscr.addch(food_y, food_x, FOOD_CHAR)\n\n        # Draw snake\n        for idx, (y, x) in enumerate(self.snake):\n            self.stdscr.addch(y, x, SNAKE_CHAR)\n\n        # Draw score\n        score_text = f"Score: {self.score}"\n        self.stdscr.addstr(0, 2, score_text)\n\n        # If game over, show message\n        if self.game_over:\n            msg = " GAME OVER! Press \'r\' to restart or \'q\' to quit "\n            self.stdscr.attron(curses.A_REVERSE)\n            self.stdscr.addstr(WINDOW_HEIGHT // 2, (WINDOW_WIDTH - len(msg)) // 2, msg)\n            self.stdscr.attroff(curses.A_REVERSE)\n\n        self.stdscr.refresh()\n\n    def handle_input(self):\n        """Process user key press."""\n        try:\n            key = self.stdscr.getch()\n        except curses.error:\n            return  # No input\n\n        if key == -1:\n            return\n\n        if key in KEY_TO_DIR:\n            self.change_direction(KEY_TO_DIR[key])\n        elif key in (ord(\'q\'), ord(\'Q\')):\n            self.game_over = True\n            self.quit_game = True\n        elif key in (ord(\'r\'), ord(\'R\')):\n            self.reset()\n\n    def run(self):\n        """Main game loop."""\n        self.stdscr.nodelay(True)  # non-blocking input\n        self.stdscr.keypad(True)   # enable special keys\n        curses.curs_set(0)         # hide cursor\n\n        self.quit_game = False\n\n        while not self.quit_game:\n            start_time = time.time()\n\n            self.handle_input()\n\n            if not self.game_over:\n                self.update()\n\n            self.draw()\n\n            # Maintain frame rate\n            elapsed = time.time() - start_time\n            time.sleep(max(0, SPEED - elapsed))\n\n# ------------------------------------------------------------------\n# Entry point\n# ------------------------------------------------------------------\ndef main(stdscr):\n    game = SnakeGame(stdscr)\n    game.run()\n\nif __name__ == "__main__":\n    curses.wrapper(main)\n```\n\n---\n\n### How to play\n\n| Key | Action |\n|-----|--------|\n| Arrow keys | Move the snake |\n| `r` | Restart after a game‚Äëover |\n| `q` | Quit the game |\n\nEnjoy! Feel free to extend the game (add levels, obstacles, high‚Äëscore list, etc.).', 'eval_count': 1690, 'eval_duration': 10500619890}
Inference completed in 10.71 seconds, 160.94 tokens/sec

Benchmarking gpt-oss:latest on GPU 0 (Run 2/5)
Running inference on model gpt-oss:latest on GPU 0
Ollama API response: {'response': 'Below is a **stand‚Äëalone Python script** that implements a classic Snake game with Pygame.  \nThe code is fully commented so you can see what each part does, and it runs out of the box if you have `pygame` installed.\n\n```python\n#!/usr/bin/env python3\n"""\nSimple Snake Game ‚Äì Python / Pygame\n-----------------------------------\nAuthor : OpenAI ChatGPT\nDate   : 2025‚Äë08‚Äë28\n\nRequirements:\n    pip install pygame\n\nHow to play:\n    ‚Ä¢ Use the arrow keys (‚Üê ‚Üë ‚Üí ‚Üì) to steer the snake.\n    ‚Ä¢ Eat the red squares (food) to grow longer.\n    ‚Ä¢ Avoid colliding with the walls or your own body.\n    ‚Ä¢ The game ends when you crash; press ESC or close the window to quit.\n\n"""\n\nimport pygame\nimport random\nimport sys\n\n# ------------------------------------------------------------------\n# Configuration constants\n# ------------------------------------------------------------------\nWINDOW_WIDTH  = 600\nWINDOW_HEIGHT = 600\nBLOCK_SIZE    = 20          # Size of one snake segment / food square\nFPS           = 10          # Base speed ‚Äì will increase as you grow\n\n# Colors (R, G, B)\nCOLOR_BG      = (0, 0, 0)          # Black background\nCOLOR_SNAKE   = (0, 255, 0)        # Green snake\nCOLOR_FOOD    = (255, 0, 0)        # Red food\nCOLOR_TEXT    = (255, 255, 255)    # White text\n\n# ------------------------------------------------------------------\n# Helper functions\n# ------------------------------------------------------------------\ndef random_food_position(snake):\n    """\n    Return a random (x, y) position that is not occupied by the snake.\n    """\n    positions = [(x, y)\n                 for x in range(0, WINDOW_WIDTH, BLOCK_SIZE)\n                 for y in range(0, WINDOW_HEIGHT, BLOCK_SIZE)]\n    # Remove positions that are part of the snake\n    positions = [p for p in positions if p not in snake]\n    return random.choice(positions)\n\n\ndef draw_text(surface, text, size, color, pos):\n    """Draw text centered at the given position."""\n    font = pygame.font.SysFont(None, size)\n    text_surface = font.render(text, True, color)\n    rect = text_surface.get_rect(center=pos)\n    surface.blit(text_surface, rect)\n\n\n# ------------------------------------------------------------------\n# Main game function\n# ------------------------------------------------------------------\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption(\'Snake\')\n\n    clock = pygame.time.Clock()\n\n    # Initial snake: 5 blocks, positioned in the middle\n    start_x = WINDOW_WIDTH // 2\n    start_y = WINDOW_HEIGHT // 2\n    snake = [(start_x - i * BLOCK_SIZE, start_y) for i in range(5)]\n    direction = (BLOCK_SIZE, 0)  # Moving right initially\n\n    # Generate first food\n    food = random_food_position(snake)\n\n    score = 0\n    game_over = False\n\n    # Main loop\n    while True:\n        # ------------------------------------------------------------------\n        # Event handling\n        # ------------------------------------------------------------------\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                # Map arrow keys to new direction\n                if event.key == pygame.K_LEFT:\n                    new_dir = (-BLOCK_SIZE, 0)\n                elif event.key == pygame.K_RIGHT:\n                    new_dir = (BLOCK_SIZE, 0)\n                elif event.key == pygame.K_UP:\n                    new_dir = (0, -BLOCK_SIZE)\n                elif event.key == pygame.K_DOWN:\n                    new_dir = (0, BLOCK_SIZE)\n                else:\n                    new_dir = None\n\n                # Prevent reversing onto itself\n                if new_dir and (new_dir[0] != -direction[0] or new_dir[1] != -direction[1]):\n                    direction = new_dir\n\n                # ESC quits\n                if event.key == pygame.K_ESCAPE:\n                    pygame.quit()\n                    sys.exit()\n\n        # ------------------------------------------------------------------\n        # Game logic (only if not over)\n        # ------------------------------------------------------------------\n        if not game_over:\n            # Move snake: insert new head based on direction\n            new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n\n            # Check for wall collision\n            if (new_head[0] < 0 or new_head[0] >= WINDOW_WIDTH or\n                new_head[1] < 0 or new_head[1] >= WINDOW_HEIGHT):\n                game_over = True\n\n            # Check for self collision\n            if new_head in snake:\n                game_over = True\n\n            if not game_over:\n                snake.insert(0, new_head)\n\n                # Check if we ate food\n                if new_head == food:\n                    score += 1\n                    # Increase speed a little as the snake grows\n                    FPS = min(30, FPS + 0.5)\n                    food = random_food_position(snake)\n                else:\n                    # Remove tail segment (move forward)\n                    snake.pop()\n\n        # ------------------------------------------------------------------\n        # Drawing\n        # ------------------------------------------------------------------\n        screen.fill(COLOR_BG)\n\n        # Draw food\n        food_rect = pygame.Rect(food[0], food[1], BLOCK_SIZE, BLOCK_SIZE)\n        pygame.draw.rect(screen, COLOR_FOOD, food_rect)\n\n        # Draw snake\n        for segment in snake:\n            rect = pygame.Rect(segment[0], segment[1], BLOCK_SIZE, BLOCK_SIZE)\n            pygame.draw.rect(screen, COLOR_SNAKE, rect)\n\n        # Draw score\n        draw_text(screen, f\'Score: {score}\', 24, COLOR_TEXT, (50, 20))\n\n        # If game over, show message\n        if game_over:\n            draw_text(screen, \'Game Over\', 48, COLOR_TEXT, (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 - 30))\n            draw_text(screen, f\'Final Score: {score}\', 36, COLOR_TEXT, (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 + 10))\n            draw_text(screen, \'Press ESC to quit\', 28, COLOR_TEXT, (WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2 + 50))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n\nif __name__ == \'__main__\':\n    main()\n```\n\n---\n\n### How it works\n\n| Section | Purpose |\n|---------|---------|\n| **Imports & constants** | Set up screen size, block size, colors, etc. |\n| **`random_food_position`** | Chooses a location that is not occupied by the snake. |\n| **`draw_text`** | Helper to center text on screen. |\n| **`main()`** | The game loop: handles input, updates game state, and draws everything. |\n| **Movement logic** | New head is added; if food is eaten we keep the tail (grow), otherwise we remove the tail. |\n| **Collision detection** | Checks walls and self‚Äëcollision to set `game_over`. |\n| **Speed increase** | `FPS` grows a bit with each food eaten, making the game harder. |\n| **Game‚Äëover UI** | Shows final score and prompts to exit. |\n\n### Running the game\n\n1. **Install Pygame** (if you don‚Äôt already have it):\n\n   ```bash\n   pip install pygame\n   ```\n\n2. **Save the script** to a file, e.g. `snake.py`.\n\n3. **Run**:\n\n   ```bash\n   python snake.py\n   ```\n\nEnjoy playing! If you‚Äôd like to tweak the speed, size, or colors, just modify the constants at the top.', 'eval_count': 1893, 'eval_duration': 11639743363}
Inference completed in 11.87 seconds, 162.63 tokens/sec

Benchmarking gpt-oss:latest on GPU 0 (Run 3/5)
Running inference on model gpt-oss:latest on GPU 0
Ollama API response: {'response': 'Below is a **complete, self‚Äëcontained Snake game written in pure Python** that uses the `pygame` library.  \nYou can copy the script into a file called `snake.py` and run it with `python snake.py`.  \nThe code is fully commented so you can follow along and tweak it if you wish.\n\n```python\n#!/usr/bin/env python3\n"""\nSnake game ‚Äì a tiny, single‚Äëfile pygame implementation.\n\nFeatures\n--------\n* Classic ‚Äúsnake‚Äù mechanics: the snake grows when it eats food.\n* Score tracking (current length, best score).\n* A simple ‚Äúgame‚Äëover‚Äù screen with the ability to restart.\n* Keyboard controls:\n    - Arrow keys or WASD ‚Äì change direction.\n    - Space ‚Äì pause / unpause.\n    - R ‚Äì restart after a game over.\n* Randomly positioned food that never appears on the snake.\n\nDependencies\n------------\n    pip install pygame\n\nAuthor : ChatGPT\n"""\n\nimport pygame\nimport random\nimport sys\n\n# ----------------------------------------------------------------------\n# Configuration ‚Äì feel free to tweak\n# ----------------------------------------------------------------------\nCELL_SIZE = 20          # pixel width/height of a single grid cell\nGRID_WIDTH = 30         # number of cells horizontally\nGRID_HEIGHT = 20        # number of cells vertically\nWINDOW_WIDTH = CELL_SIZE * GRID_WIDTH\nWINDOW_HEIGHT = CELL_SIZE * GRID_HEIGHT\n\nFPS = 10                # snake speed ‚Äì increase for a faster snake\nSNAKE_COLOR = (0, 255, 0)   # green\nFOOD_COLOR = (255, 0, 0)    # red\nBG_COLOR = (0, 0, 0)        # black\nTEXT_COLOR = (255, 255, 255)  # white\n\n# ----------------------------------------------------------------------\n# Helper functions\n# ----------------------------------------------------------------------\ndef random_food_position(snake):\n    """Return a random grid position that is not occupied by the snake."""\n    while True:\n        pos = (random.randint(0, GRID_WIDTH-1),\n               random.randint(0, GRID_HEIGHT-1))\n        if pos not in snake:\n            return pos\n\n\ndef draw_cell(surface, color, position):\n    """Draw a single cell at a grid position."""\n    rect = pygame.Rect(position[0]*CELL_SIZE,\n                       position[1]*CELL_SIZE,\n                       CELL_SIZE, CELL_SIZE)\n    pygame.draw.rect(surface, color, rect)\n\n\ndef draw_grid(surface):\n    """Optional: draw a faint grid to help the eye."""\n    for x in range(0, WINDOW_WIDTH, CELL_SIZE):\n        pygame.draw.line(surface, (50, 50, 50), (x, 0), (x, WINDOW_HEIGHT))\n    for y in range(0, WINDOW_HEIGHT, CELL_SIZE):\n        pygame.draw.line(surface, (50, 50, 50), (0, y), (WINDOW_WIDTH, y))\n\n\n# ----------------------------------------------------------------------\n# Main game loop\n# ----------------------------------------------------------------------\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption("Snake ‚Äì Pygame Edition")\n    clock = pygame.time.Clock()\n    font = pygame.font.SysFont(None, 36)\n\n    # Game state\n    snake = [(GRID_WIDTH//2, GRID_HEIGHT//2)]  # start at center\n    direction = (0, -1)  # initially moving up\n    food = random_food_position(snake)\n    score = 0\n    best_score = 0\n    paused = False\n    game_over = False\n\n    while True:\n        # ------------------------------------------------------------------\n        # Input handling\n        # ------------------------------------------------------------------\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                # Movement keys (arrow keys or WASD)\n                if event.key in (pygame.K_UP, pygame.K_w):\n                    if direction != (0, 1):  # can\'t reverse\n                        direction = (0, -1)\n                elif event.key in (pygame.K_DOWN, pygame.K_s):\n                    if direction != (0, -1):\n                        direction = (0, 1)\n                elif event.key in (pygame.K_LEFT, pygame.K_a):\n                    if direction != (1, 0):\n                        direction = (-1, 0)\n                elif event.key in (pygame.K_RIGHT, pygame.K_d):\n                    if direction != (-1, 0):\n                        direction = (1, 0)\n\n                # Pause / unpause\n                elif event.key == pygame.K_SPACE:\n                    paused = not paused\n\n                # Restart after game over\n                elif event.key == pygame.K_r and game_over:\n                    # Reset everything\n                    snake = [(GRID_WIDTH//2, GRID_HEIGHT//2)]\n                    direction = (0, -1)\n                    food = random_food_position(snake)\n                    score = 0\n                    game_over = False\n                    paused = False\n\n        # ------------------------------------------------------------------\n        # Update game logic (only if not paused or over)\n        # ------------------------------------------------------------------\n        if not paused and not game_over:\n            # Move snake\n            new_head = ((snake[0][0] + direction[0]) % GRID_WIDTH,\n                        (snake[0][1] + direction[1]) % GRID_HEIGHT)\n\n            # Collision with self\n            if new_head in snake:\n                game_over = True\n                if score > best_score:\n                    best_score = score\n            else:\n                snake.insert(0, new_head)\n\n                # Check food\n                if new_head == food:\n                    score += 1\n                    food = random_food_position(snake)\n                else:\n                    snake.pop()  # remove tail (keep length constant)\n\n        # ------------------------------------------------------------------\n        # Drawing\n        # ------------------------------------------------------------------\n        screen.fill(BG_COLOR)\n        draw_grid(screen)\n\n        # Draw food\n        draw_cell(screen, FOOD_COLOR, food)\n\n        # Draw snake\n        for segment in snake:\n            draw_cell(screen, SNAKE_COLOR, segment)\n\n        # Draw score\n        score_surf = font.render(f"Score: {score}  Best: {best_score}", True, TEXT_COLOR)\n        screen.blit(score_surf, (10, 10))\n\n        # Game over overlay\n        if game_over:\n            over_surf = font.render("GAME OVER! Press R to restart", True, TEXT_COLOR)\n            rect = over_surf.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2))\n            screen.blit(over_surf, rect)\n\n        # Pause overlay\n        if paused and not game_over:\n            pause_surf = font.render("PAUSED", True, TEXT_COLOR)\n            rect = pause_surf.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2))\n            screen.blit(pause_surf, rect)\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n\n# ----------------------------------------------------------------------\n# Entry point\n# ----------------------------------------------------------------------\nif __name__ == "__main__":\n    main()\n```\n\n---\n\n## How to run\n\n1. **Install `pygame`**\n\n   ```bash\n   pip install pygame\n   ```\n\n2. **Save the code** to a file called `snake.py`.\n\n3. **Run**\n\n   ```bash\n   python snake.py\n   ```\n\n---\n\n## Controls\n\n| Key | Action |\n|-----|--------|\n| Arrow keys or **W/A/S/D** | Change direction |\n| **Space** | Pause / unpause |\n| **R** | Restart after game over |\n| **Esc** or close window | Quit |\n\n---\n\n### Tweaking the game\n\n- **Speed** ‚Äì change `FPS` at the top.  \n- **Grid size** ‚Äì adjust `GRID_WIDTH`, `GRID_HEIGHT`, `CELL_SIZE`.  \n- **Colors** ‚Äì modify the RGB tuples at the top.  \n- **Add walls** ‚Äì insert a check for collisions with a wall boundary.  \n\nEnjoy! üéÆ', 'eval_count': 1694, 'eval_duration': 10442850620}
Inference completed in 10.65 seconds, 162.22 tokens/sec

Benchmarking gpt-oss:latest on GPU 0 (Run 4/5)
Running inference on model gpt-oss:latest on GPU 0
Ollama API response: {'response': 'Below is a **complete, self‚Äëcontained Python implementation of the classic Snake game** using the `pygame` library.  \nFeel free to copy‚Äëpaste the file, install `pygame`, and run it.  \n\n---\n\n## 1Ô∏è‚É£  Prerequisites\n\n```bash\npip install pygame\n```\n\n> **Tip** ‚Äì If you‚Äôre on Windows and see a ‚Äúmissing pygame‚Äù error, make sure you‚Äôre using a Python interpreter that has `pygame` installed in the same environment.\n\n---\n\n## 2Ô∏è‚É£  How to Play\n\n| Key | Action |\n|-----|--------|\n| Arrow keys (‚Üê ‚Üë ‚Üí ‚Üì) | Change the snake‚Äôs direction |\n| `R` | Restart the game after a crash |\n| `Q` or `Esc` | Quit the game |\n\nCollect the red food squares to grow the snake and increase your score. If the snake hits the wall or itself the game ends.  \n\n---\n\n## 3Ô∏è‚É£  Full Source Code\n\n```python\n#!/usr/bin/env python3\n"""\nSnake Game\n----------\nA minimal yet fully functional Snake game implemented with pygame.\n\nAuthor:  Your Name\nDate:    2025-08-28\n"""\n\nimport sys\nimport random\nimport pygame\n\n# --------------------------------------------------------------------------- #\n# 1. CONFIGURATION\n# --------------------------------------------------------------------------- #\nWINDOW_WIDTH = 600           # Width of the window (in pixels)\nWINDOW_HEIGHT = 400          # Height of the window (in pixels)\nCELL_SIZE = 20               # Size of one grid cell (in pixels)\nGRID_WIDTH = WINDOW_WIDTH // CELL_SIZE\nGRID_HEIGHT = WINDOW_HEIGHT // CELL_SIZE\n\nFPS = 10                     # Frames per second (controls speed)\nSNAKE_COLOR = (0, 255, 0)    # Snake (green)\nFOOD_COLOR = (255, 0, 0)     # Food (red)\nBG_COLOR = (0, 0, 0)         # Background (black)\nTEXT_COLOR = (255, 255, 255)# Text (white)\n\n# --------------------------------------------------------------------------- #\n# 2. HELPER CLASSES\n# --------------------------------------------------------------------------- #\nclass Snake:\n    """Represents the snake as a list of grid positions."""\n    def __init__(self):\n        self.positions = [(GRID_WIDTH // 2, GRID_HEIGHT // 2)]  # Start in the center\n        self.direction = (0, -1)  # Initially moving up\n\n    def head_position(self):\n        return self.positions[0]\n\n    def turn(self, dir):\n        """Change direction, preventing 180¬∞ turns."""\n        if (dir[0] * -1, dir[1] * -1) == self.direction:\n            # Ignore reverse direction\n            return\n        self.direction = dir\n\n    def move(self):\n        """Move snake forward in the current direction."""\n        cur = self.head_position()\n        new = ((cur[0] + self.direction[0]) % GRID_WIDTH,\n               (cur[1] + self.direction[1]) % GRID_HEIGHT)\n\n        # If snake collides with itself\n        if new in self.positions:\n            raise ValueError("Snake collided with itself!")\n\n        self.positions.insert(0, new)  # New head\n        # Default behaviour: remove tail (unless we just ate food)\n        return new\n\n    def grow(self):\n        """Call after moving to grow the snake (i.e., don\'t pop the tail)."""\n        pass  # We\'ll simply skip popping the tail in the main loop\n\n    def pop_tail(self):\n        """Remove the last element of the snake (tail)."""\n        self.positions.pop()\n\n    def draw(self, surface):\n        for pos in self.positions:\n            rect = pygame.Rect(pos[0]*CELL_SIZE, pos[1]*CELL_SIZE,\n                               CELL_SIZE, CELL_SIZE)\n            pygame.draw.rect(surface, SNAKE_COLOR, rect)\n\nclass Food:\n    """Represents the food that the snake eats."""\n    def __init__(self, snake_positions):\n        self.position = self._random_position(snake_positions)\n\n    def _random_position(self, snake_positions):\n        available = [(x, y) for x in range(GRID_WIDTH)\n                               for y in range(GRID_HEIGHT)\n                               if (x, y) not in snake_positions]\n        if not available:\n            raise ValueError("No space left for food!")\n        return random.choice(available)\n\n    def draw(self, surface):\n        rect = pygame.Rect(self.position[0]*CELL_SIZE,\n                           self.position[1]*CELL_SIZE,\n                           CELL_SIZE, CELL_SIZE)\n        pygame.draw.rect(surface, FOOD_COLOR, rect)\n\n# --------------------------------------------------------------------------- #\n# 3. MAIN GAME LOGIC\n# --------------------------------------------------------------------------- #\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption("Snake")\n    clock = pygame.time.Clock()\n    font = pygame.font.SysFont(None, 36)\n\n    # Initialize game objects\n    snake = Snake()\n    food = Food(snake.positions)\n    score = 0\n    crashed = False\n\n    # Map keys to directions\n    key_dir_map = {\n        pygame.K_UP:    (0, -1),\n        pygame.K_DOWN:  (0,  1),\n        pygame.K_LEFT:  (-1, 0),\n        pygame.K_RIGHT: (1,  0),\n    }\n\n    while True:\n        # ----- Event handling -----\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key in key_dir_map:\n                    snake.turn(key_dir_map[event.key])\n                if crashed:\n                    if event.key == pygame.K_r:\n                        # Restart game\n                        snake = Snake()\n                        food = Food(snake.positions)\n                        score = 0\n                        crashed = False\n                    elif event.key in (pygame.K_q, pygame.K_ESCAPE):\n                        pygame.quit()\n                        sys.exit()\n\n        if not crashed:\n            # ----- Game update -----\n            try:\n                new_head = snake.move()\n                # Check food collision\n                if new_head == food.position:\n                    score += 1\n                    snake.grow()        # Don\'t pop tail this turn\n                    food = Food(snake.positions)\n                else:\n                    snake.pop_tail()\n            except ValueError:\n                crashed = True\n\n        # ----- Drawing -----\n        screen.fill(BG_COLOR)\n        snake.draw(screen)\n        food.draw(screen)\n\n        # Draw score\n        score_surf = font.render(f"Score: {score}", True, TEXT_COLOR)\n        screen.blit(score_surf, (5, 5))\n\n        if crashed:\n            game_over_surf = font.render("GAME OVER! Press R to restart", True, TEXT_COLOR)\n            rect = game_over_surf.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2))\n            screen.blit(game_over_surf, rect)\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == "__main__":\n    main()\n```\n\n---\n\n## 4Ô∏è‚É£  How the Code Works\n\n| Section | What It Does |\n|---------|--------------|\n| **Configuration** | Window size, grid size, colors, FPS, etc. |\n| **`Snake` class** | Keeps track of positions, direction, moving, growing, and rendering. |\n| **`Food` class** | Picks a random grid cell not occupied by the snake and renders it. |\n| **Main loop** | Handles input, updates game state, checks for collisions, renders everything, and manages the crash state. |\n\nThe game runs in a **fixed grid** ‚Äì the snake‚Äôs head always snaps to grid cells, simplifying collision detection.\n\n---\n\n## 5Ô∏è‚É£  Extending the Game\n\n| Feature | How to Add |\n|---------|------------|\n| **Increase speed** | Increase `FPS` or multiply it over time. |\n| **High‚Äëscore persistence** | Save the highest score to a file (`pickle`, `json`, or plain text). |\n| **Pause** | Add a boolean `paused` flag toggled by a key (e.g., `P`). |\n| **Sound** | Load sound files and play on eating food or crashing. |\n| **Responsive window** | Recalculate `GRID_WIDTH/HEIGHT` on resize events. |\n\n---\n\nEnjoy the game, tweak it, and share your improvements! If you run into any problems, feel free to ask. Happy coding!', 'eval_count': 2043, 'eval_duration': 12632590671}
Inference completed in 12.87 seconds, 161.72 tokens/sec

Benchmarking gpt-oss:latest on GPU 0 (Run 5/5)
Running inference on model gpt-oss:latest on GPU 0
Ollama API response: {'response': 'Below is a **complete, ready‚Äëto‚Äërun** Python implementation of the classic ‚ÄúSnake‚Äù game.  \nIt uses `pygame`, the most popular library for 2D games in Python.  \n\n> **How to run it**  \n> 1. Install pygame (if you haven‚Äôt already):  \n>    ```bash\n>    pip install pygame\n>    ```  \n> 2. Save the code below into a file called `snake.py`.  \n> 3. Run it with `python snake.py`.  \n\nYou‚Äôll see a window with a black background. The snake is a green rectangle, the food is a red square. Use the arrow keys (or **WASD**) to steer. The game ends when the snake collides with itself or the walls. The current score (number of food items eaten) is displayed in the upper‚Äëleft corner.\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n"""\nSnake Game ‚Äì Pygame Implementation\n\nAuthor:  ChatGPT\nDate:    2025-08-28\n"""\n\nimport pygame\nimport random\nimport sys\n\n# ---------- Configuration ----------\nWINDOW_SIZE = 600          # Window is WINDOW_SIZE x WINDOW_SIZE pixels\nGRID_SIZE   = 20           # Number of grid cells per row/col\nCELL_SIZE   = WINDOW_SIZE // GRID_SIZE  # Size of one cell in pixels\nFPS         = 10           # Game speed (frames per second)\n\n# Colors (R, G, B)\nBG_COLOR     = (0, 0, 0)          # Black background\nSNAKE_COLOR  = (0, 255, 0)        # Green snake\nFOOD_COLOR   = (255, 0, 0)        # Red food\nTEXT_COLOR   = (255, 255, 255)    # White text\nBORDER_COLOR = (40, 40, 40)       # Dark gray border\n\n# Direction constants\nUP    = (0, -1)\nDOWN  = (0, 1)\nLEFT  = (-1, 0)\nRIGHT = (1, 0)\nOPPOSITE = {UP: DOWN, DOWN: UP, LEFT: RIGHT, RIGHT: LEFT}\n\n# ---------- Utility Functions ----------\ndef random_food_position(snake):\n    """Return a random grid position that is not occupied by the snake."""\n    while True:\n        pos = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        if pos not in snake:\n            return pos\n\ndef draw_grid(screen):\n    """Optional: draw grid lines to help visualise the cells."""\n    for x in range(0, WINDOW_SIZE, CELL_SIZE):\n        pygame.draw.line(screen, BORDER_COLOR, (x, 0), (x, WINDOW_SIZE))\n    for y in range(0, WINDOW_SIZE, CELL_SIZE):\n        pygame.draw.line(screen, BORDER_COLOR, (0, y), (WINDOW_SIZE, y))\n\ndef blit_rect(screen, color, grid_pos):\n    """Draw a rectangle at the given grid position."""\n    rect = pygame.Rect(grid_pos[0] * CELL_SIZE,\n                       grid_pos[1] * CELL_SIZE,\n                       CELL_SIZE, CELL_SIZE)\n    pygame.draw.rect(screen, color, rect)\n\n# ---------- Main Game Class ----------\nclass SnakeGame:\n    def __init__(self):\n        pygame.init()\n        pygame.display.set_caption(\'Snake ‚Äì PyGame Edition\')\n        self.screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n        self.clock = pygame.time.Clock()\n        self.font = pygame.font.SysFont(\'monospace\', 24, bold=True)\n\n        self.reset()\n\n    def reset(self):\n        """Initialize or restart the game state."""\n        # Snake starts in the middle, length 3\n        mid = GRID_SIZE // 2\n        self.snake = [(mid, mid), (mid - 1, mid), (mid - 2, mid)]\n        self.direction = RIGHT\n        self.food = random_food_position(self.snake)\n        self.score = 0\n        self.game_over = False\n\n    def handle_input(self):\n        """Handle keyboard events."""\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            elif event.type == pygame.KEYDOWN:\n                if event.key in (pygame.K_UP, pygame.K_w):\n                    self.try_change_direction(UP)\n                elif event.key in (pygame.K_DOWN, pygame.K_s):\n                    self.try_change_direction(DOWN)\n                elif event.key in (pygame.K_LEFT, pygame.K_a):\n                    self.try_change_direction(LEFT)\n                elif event.key in (pygame.K_RIGHT, pygame.K_d):\n                    self.try_change_direction(RIGHT)\n                elif event.key == pygame.K_r and self.game_over:\n                    self.reset()\n\n    def try_change_direction(self, new_dir):\n        """Change snake direction if it is not opposite to current."""\n        if OPPOSITE.get(self.direction) != new_dir:\n            self.direction = new_dir\n\n    def move_snake(self):\n        """Move snake forward by one cell. Return False if collision."""\n        head_x, head_y = self.snake[0]\n        dir_x, dir_y = self.direction\n        new_head = (head_x + dir_x, head_y + dir_y)\n\n        # Check wall collision\n        if (not 0 <= new_head[0] < GRID_SIZE or\n            not 0 <= new_head[1] < GRID_SIZE):\n            return False\n\n        # Check self collision\n        if new_head in self.snake:\n            return False\n\n        # Insert new head\n        self.snake.insert(0, new_head)\n\n        # Check food\n        if new_head == self.food:\n            self.score += 1\n            self.food = random_food_position(self.snake)\n        else:\n            # Remove tail\n            self.snake.pop()\n\n        return True\n\n    def update(self):\n        """Update the game state. Return False if game over."""\n        if not self.move_snake():\n            self.game_over = True\n            return False\n        return True\n\n    def draw(self):\n        """Render everything to the screen."""\n        self.screen.fill(BG_COLOR)\n\n        # Optional: draw grid lines\n        # draw_grid(self.screen)\n\n        # Draw food\n        blit_rect(self.screen, FOOD_COLOR, self.food)\n\n        # Draw snake\n        for segment in self.snake:\n            blit_rect(self.screen, SNAKE_COLOR, segment)\n\n        # Draw score\n        score_surf = self.font.render(f\'Score: {self.score}\', True, TEXT_COLOR)\n        self.screen.blit(score_surf, (10, 10))\n\n        # Draw game over message\n        if self.game_over:\n            over_surf = self.font.render(\'GAME OVER! Press R to Restart\', True, TEXT_COLOR)\n            rect = over_surf.get_rect(center=(WINDOW_SIZE // 2, WINDOW_SIZE // 2))\n            self.screen.blit(over_surf, rect)\n\n        pygame.display.flip()\n\n    def run(self):\n        """Main game loop."""\n        while True:\n            self.handle_input()\n\n            if not self.game_over:\n                self.update()\n\n            self.draw()\n            self.clock.tick(FPS)\n\n# ---------- Entry Point ----------\nif __name__ == \'__main__\':\n    game = SnakeGame()\n    game.run()\n```\n\n### What you‚Äôll see\n\n| Feature | How it works |\n|---------|--------------|\n| **Snake movement** | Controlled by arrow keys or WASD. |\n| **Food** | Appears randomly. Eating it grows the snake and increases the score. |\n| **Collision detection** | The game ends if the snake hits the window border or its own body. |\n| **Score** | Number of food items eaten, displayed at the top‚Äëleft. |\n| **Restart** | After game over, press **R** to start over. |\n\nFeel free to tweak the configuration at the top of the script (e.g., speed, grid size, colors) to suit your taste. Happy coding!', 'eval_count': 1792, 'eval_duration': 10975303006}
Inference completed in 11.16 seconds, 163.28 tokens/sec
Results saved to benchmark_results.json

==================================================
BENCHMARK SUMMARY
==================================================

Model: gpt-oss:latest
  GPU 0: 162.16 tokens/sec (avg of 5 runs)
